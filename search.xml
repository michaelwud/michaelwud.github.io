<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018牛客暑假多校训练第五场D题]]></title>
    <url>%2F2019%2F01%2F26%2F2018%E7%89%9B%E5%AE%A2%E6%9A%91%E5%81%87%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%BA%94%E5%9C%BAD%E9%A2%98%2F</url>
    <content type="text"><![CDATA[###Topic2018牛客暑假多校训练第五场D题 ###Solution 考虑题意，转化为将奇数插入给定偶数序列使得逆序对数最少 偶数序列自身有逆序对，将对答案产生贡献，使用树状数组即可在O(nlogn)时间内求得 考虑奇数插入后产生的贡献，这里可以证明奇数从小到大的插入位置为递增的 证明：现在假设对于$a_i$这个数字插入的最优位置为$k$，那么当要插入$a_i + 2$这个数字时，会产生影响的只有$a_i + 1$ 假设$a_i + 1$在$k$的左边，那么我们把它暂时删去不看，此时添加$a_i + 2$的最优位置应该仍为$k$，那么此时加回$a_i + 1$，在$k$的左边，并不会产生贡献，故$a_i + 2$的最优位置仍为$k$。 假设$a_i + 1$在$k$的右边，依旧暂时删去不看$a_i + 1$，$a_i + 2$的最优位置为$k$，加回$a_i + 1$，若$a_i + 2$往右挪到$a_i + 1$的右边时，会减少$a_i + 1$的贡献，故$a_i + 2$的最优位置可能为$a_i + 1$的右边 综上，$a_i + 2$的最优位置在$k$的右边 那么奇数间没有逆序对，而我们只需要累加每个奇数的插入的最少逆序对数即可。 维护一棵线段树，当要求$a_i + 2$的贡献时，将$a_i + 1$左边的位置贡献全部加一，右边的贡献全部减一，求整个区间的最小值，区间更新区间询问。###Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;assert.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-10;const int maxn = 2e5 + 7;const int mod = 1e9 + 7;const double pi = acos(-1);#define FOR(i, j, k) for(int i = j;i &lt; k; ++i)#define PRE(i, j, k) for(int i = j - 1;i &gt;= k; --i)#define z i &lt;&lt; 1#define y i &lt;&lt; 1 | 1int n, a[maxn], b[maxn], pos[maxn];ll ans;void add(int p)&#123; while(p &lt;= n) &#123; b[p]++; p += p &amp; -p; &#125;&#125;ll sum(int p)&#123; ll tmp = 0; while(p &gt; 0) &#123; tmp += b[p]; p -= p &amp; -p; &#125; return tmp;&#125;struct G&#123; int l, r, m, lazy; G()&#123;&#125; G(int l, int r, int m = 0, int lazy = 0):l(l), r(r), m(m), lazy(lazy)&#123;&#125;&#125; tr[maxn &lt;&lt; 2];void push_up(int i)&#123; tr[i].m = min(tr[z].m, tr[y].m);&#125;void push_down(int i)&#123; int lazy = tr[i].lazy; tr[z].m += lazy, tr[y].m += lazy; tr[z].lazy += lazy, tr[y].lazy += lazy; tr[i].lazy = 0;&#125;void build(int l = 0, int r = n, int i = 1)&#123; tr[i] = G(l, r); if(l == r) &#123; tr[i].m = l; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; build(l, mid, z); build(mid + 1, r, y); push_up(i); &#125;&#125;void udt(int l, int r, int val, int i = 1)&#123; int L = tr[i].l, R = tr[i].r; if(L == l &amp;&amp; R == r) &#123; tr[i].m += val;tr[i].lazy += val; &#125; else &#123; int mid = (L + R) &gt;&gt; 1; push_down(i); if(l &lt;= mid) udt(l, min(r, mid), val, z); if(r &gt; mid) udt(max(l, mid + 1), r, val, y); push_up(i); &#125;&#125;int ask(int l = 0, int r = n, int i = 1)&#123; int L = tr[i].l, R = tr[i].r; if(L == l &amp;&amp; R == r) &#123; return tr[i].m; &#125; else &#123; int mid = (L + R) &gt;&gt;1; int res = INF; if(l &lt;= mid) res = min(res, ask(l, min(r, mid), z)); if(r &gt; mid) res = min(res, ask(max(l, mid + 1), y)); return res; &#125;&#125;int main()&#123;// freopen("input.txt","r",stdin); ans = 0; scanf("%d", &amp;n); FOR(i, 0, n/2) scanf("%d", a + i), pos[a[i]] = i; PRE(i, n/2, 0) ans += sum(a[i]), add(a[i]); build(); for(int i = 3;i &lt; n;i += 2) &#123; int p = pos[i - 1]; udt(0, p, 1); udt(p + 1, n, -1); ans += ask(); &#125; printf("%lld\n", ans); return 0;&#125;/**************/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>线段树</tag>
        <tag>牛客网</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 6350]]></title>
    <url>%2F2019%2F01%2F23%2Fhdu6350%2F</url>
    <content type="text"><![CDATA[Topicproblem linkAlways Online Time Limit: 8000/4000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others)Total Submission(s): 208 Accepted Submission(s): 66 Problem DescriptionWayne is an administrator of some metropolitan area network. The network he managed can be formed into a simple connected graph with n vertices and m edges, which means the graph does not contain any self-loop and there is at most one edge and at least one path between every two vertices. Furthermore, the network also meets the condition there are at most two non-intersect paths, which share no common edges, between every two vertices. Wayne knows the bandwidth of each edge in that network but it is not enough for him. He needs plenty of statistic data to display, for example, he wants to know what the maximum data rate between every two vertices is. For the sake of clarity, vertices in that are numbered from 1 to n and the maximum bits each edge could transmit per second will be given. Your task is assisting him to calculate the value of the following formula: ∑1≤s&lt;t≤n(s⊕t⊕flow(s,t)), where ⊕ means the bitwise exclusive-OR operator and flow(s,t) means the maximum bits that could be transmitted per second between vertex s and vertex t. InputThe first line contains one integer T, indicating the number of test cases.The following lines describe all the test cases. For each test case:The first line contains two integers n and m.Each of the following m lines contains three integers u,v and w, indicating a bidirectional edge between vertex u and vertex v that can transmit at most w bits per second in each direction.1≤T≤100, 1≤n≤105, n−1≤m≤32(n−1), 1≤u,v≤n, u≠v, 0≤w&lt;109.It is guaranteed that the sum of n in all test cases does not exceed 106 and the size of the standard input file does not exceed 26 MiB. OutputFor each test case, print the answer in one line. Sample Input23 31 2 52 3 63 1 55 61 2 52 3 63 1 53 4 64 5 55 3 6 Sample Output27116 Hint For the first sample, flow(1, 2) = flow(1, 3) = 10, flow(2, 3) = 11. Intention给出一个无向图，不存在自环，两点间最多有一条边，两点间至少有一条路径，至多两条不相交路径。给出每条边以及两边之间的容量，询问 Solution 考虑这个图，其实就是一个仙人掌，大概就是长这样： 考虑如果是一棵树，那么两点最大流，即最小割就是两点路径上最小的边权 考虑仙人掌，意识流一下，对于两个点的最小割可能要割两条边，而这两条边一定在同一个环内，且环内最小边一定会被割掉 那么就可以预处理先把每个环内最小边删除并将权值加到这个环的每一条边上，此时将变成一棵树 对于一棵树，我们将所有边按权值从大到小枚举，通过并查集，按位记录点的贡献，对于每条边，再算出该边的贡献，累加即是答案 一开始用vector去跑图竟然爆栈了，大概是因为边太多的原因，本地扩栈不会爆RE，所以改了std的dfs写法，解决了segment fault 的问题，然后TLE了，将位统计的64改成32就ac了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;functional&gt;#include &lt;ctime&gt;#include &lt;assert.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const ll mod = 1e9 + 7;const double PI = acos(-1.0);const double eps = 1e-10;const int maxn = 4e5 + 7;#define REP(i, j, k) for(int i = j;i &lt;= k; ++i)#define PER(i, j, k) for(int i = j;i &gt;= k; --i)int t, n, m, vis[maxn], dep[maxn], prt[maxn], bit[maxn][40], num[maxn], tot, fae[maxn], f[maxn];int e[maxn], g[maxn], nt[maxn];struct G&#123; int u, v, w, id; G()&#123;&#125; G(int u, int v, int w, int id):u(u), v(v), w(w), id(id)&#123;&#125; bool operator &lt; (const G &amp; b) const &#123;return w &gt; b.w;&#125;&#125; edge[maxn];int get_prt(int a)&#123; return prt[a] = (prt[a] == a) ? a : get_prt(prt[a]);&#125;ll Union (int a, int b, int w)&#123; int fa = get_prt(a), fb = get_prt(b); ll res = 0; if(fa == fb) return res; REP(i, 0, 31) &#123; if(!(w &amp; (1ll &lt;&lt; i))) &#123; res += 1ll * bit[fa][i] * (num[fb] - bit[fb][i]) * (1ll &lt;&lt; i); res += 1ll * (num[fa] - bit[fa][i]) * bit[fb][i] * (1ll &lt;&lt; i); &#125; else &#123; res += 1ll * bit[fa][i] * bit[fb][i] * (1ll &lt;&lt; i); res += 1ll * (num[fa] - bit[fa][i]) * (num[fb] - bit[fb][i]) * (1ll &lt;&lt; i); &#125; &#125; prt[fb] = fa; num[fa] += num[fb]; REP(i, 0, 31) &#123; bit[fa][i] += bit[fb][i]; &#125; return res;&#125;void init()&#123; memset(dep, 0, sizeof(dep)); memset(vis, 0, sizeof(vis)); memset(fae, 0, sizeof(fae)); memset(bit, 0, sizeof(bit)); memset(f, 0, sizeof(f)); memset(nt, 0, sizeof(nt)); memset(g, 0, sizeof(g));&#125;void adde(int u, int v)&#123; e[++tot] = v; nt[tot] = g[u]; g[u] = tot; e[++tot] = u; nt[tot] = g[v]; g[v] = tot;&#125;void dfs(int u, int pre)&#123; f[u] = pre; dep[u] = ++tot; for(int i = g[u];i;i = nt[i]) &#123; if(e[i] == pre) continue; if(!dep[e[i]]) fae[e[i]] = i &gt;&gt; 1, dfs(e[i], u); else if(dep[e[i]] &lt; dep[u]) &#123; int v = u; vector&lt;int&gt; vec; vec.push_back(i &gt;&gt; 1); while(v != e[i]) vec.push_back(fae[v]), v = f[v]; int Min = 1e9 + 1, pos = 0; REP(j, 0, vec.size() - 1) &#123; if(edge[vec[j]].w &lt; Min) Min = edge[vec[j]].w, pos = j; &#125; vis[vec[pos]] = 1; REP(j, 0, vec.size() - 1) &#123; if(j != pos) edge[vec[j]].w += edge[vec[pos]].w; &#125; &#125; &#125;&#125;int main()&#123;#ifdef DEBUG freopen("input.txt", "r", stdin);#endif // DEBUG scanf("%d", &amp;t); while(t--) &#123; init(); scanf("%d %d", &amp;n, &amp;m); REP(i, 1, n) &#123; int _i = i, cnt = 0; while(_i) bit[i][cnt++] = _i % 2, _i /= 2; num[i] = 1; prt[i] = i; &#125; int u, v, w; tot = 1; REP(i, 1, m) scanf("%d %d %d", &amp;u, &amp;v, &amp;w), edge[i] = G(u, v, w, i), adde(u, v); dfs(1, 0); sort(edge + 1, edge + m + 1); ll ans = 0; REP(i, 1, m) &#123; if(vis[edge[i].id]) continue; int u = edge[i].u, v = edge[i].v, w = edge[i].w; //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl; ans += Union(u, v, w); &#125; printf("%llu\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>网络流</tag>
        <tag>并查集</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
</search>
