<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018徐州网络赛d题 Easy Math]]></title>
    <url>%2F2019%2F01%2F27%2F2018%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9Bd%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2018徐州网络赛d题 Easy Math Topic Intention题意很简单，但却不好做（懂了之后就会觉得很好做，都是套路）毕竟数论题给出莫比乌斯函数定义，求 $\sum_{i = 1}^m u(i * n)$ Solution 考虑到莫比乌斯函数为积性函数，尝试分析：$\sum_{i = 1}^m u(i n) = \sum_{i = 1}^m u(i) u(n)[gcd(i, n) = 1]$ 看到[gcd(i, n) = 1] 很开心，马上写反演：$=u(n) \sum_{g | n} \sum_{t = 1}^{\lfloor \frac m t \rfloor} u(t g)\sum_{d | g} u(d)$继续化简得$=u(n) \sum_{d | n} \sum_{t = 1}^{\lfloor \frac m t \rfloor} u(t d) u(d) = u(n) \sum_{d | n} u(d) \sum_{t = 1}^{\lfloor \frac m t \rfloor} u(t d)$令原式子为$G(n, m)$则可发现式子为$G(n, m) = u(n) \sum_{d | n} G(d, \lfloor \frac m d \rfloor)$ 然后考虑当u（n） == 0 时，答案为0，当不为 0 时，必然有 $n = p_1 p_2 …p_n$，而n范围为1e12，最多由13个素数相乘得到，于是可以$2^{13}$枚举因子数（一开始化到这里贼开心，都开始敲代码了，然后又觉得没那么简单，就多看一眼，发现复杂度不大对，因为m有1e9。。那时候还没学杜教筛，所以比赛中没能做出来） 所以继续化简，其实就我的理解，杜教筛不过就是把1的情况拿了出来单独运算罢了，其他照旧，于是有操作：$G(n, m) = u(n) \sum_{d | n} G(d, \lfloor \frac m d \rfloor)$$= u(n) *[\sum_{d|n\&amp;\&amp;d != 1}G(d, \lfloor \frac m d\rfloor) + \sum_{t = 1}^mu(t)]$ 发现后面那部分就是经典的杜教筛了，直接做就可以了 思考复杂度，枚举因子$2^{13}$，后面是$\lfloor \frac m d \rfloor$log减小，考虑dfs树的话，就是深搜log层，每层枚举因子$2^{13}$，然后每个因子计算杜教筛那部分为$O(\lfloor \frac m d \rfloor^{\frac 2 3})$，即$\sum_{d | n} \lfloor \frac m d \rfloor ^ {\frac 2 3}$，因为$\lfloor \frac m d \rfloor^{\frac 2 3}$难算（可能要用积分，不管了，太懒了），因此考虑更广泛的情况m / d，在m / d的情况下为$m log(m)$，类比一下，每层复杂度大约为$O(m^{\frac 2 3} log(m ^{\frac 2 3}))$（yy 一下），然后因为有$log$层，故时间复杂度大概为$O(m^{\frac 2 3} log(m ^{\frac 2 3}) log(m))$，事实上复杂度应该更小的，跑起来飞快 Code 第一份ac代码，写得有点臭123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;ctime&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const ll LINF = 0x3f3f3f3f3f3f3f3f;const int INF = 0x7f7f7f7f;const ll mod = 1e9 + 7;const double PI = acos(-1.0);const double eps = 1e-6;const int maxn = 1e6 + 7;#define REP(i, j, k) for(int i = j;i &lt; k; ++i)#define PER(i, j, k) for(int i = k - 1;i &gt;= j; --i)ll n, m;ll p[maxn], vis[maxn], mu[maxn], cnt;ll d[maxn], sz;map&lt;ll, ll&gt; mp;void init()&#123; sz = cnt = 0; mu[1] = 1; REP(i, 2, maxn) &#123; if(!vis[i]) p[cnt++] = i, mu[i] = -1; REP(j, 0, cnt) &#123; if(p[j] * i &gt;= maxn) break; vis[i * p[j]] = 1; if(i % p[j] == 0) &#123; mu[i * p[j]] = 0; break; &#125; mu[i * p[j]] = -mu[i]; &#125; &#125; REP(i, 2, maxn) &#123; mu[i] = mu[i] + mu[i - 1]; &#125;&#125;ll did(ll m)&#123; if(m &lt; maxn) return mu[m]; if(mp.find(m) != mp.end()) return mp[m]; ll res = 1; ll last; for(ll i = 2;i &lt;= m;i = last + 1) &#123; last = m / (m / i); res -= (last - i + 1) * did(m / i); &#125; return mp[m] = res;&#125;ll solve(ll m, ll d[], ll sz)&#123; if(m == 0) return 0; ll res = did(m); ll u[14], nsz; REP(i, 1, 1 &lt;&lt; sz) &#123; ll nd = 1; nsz = 0; REP(j, 0, sz) &#123; if(i &amp; (1 &lt;&lt; j)) nd *= d[j], u[nsz++] = d[j]; &#125; res += ((nsz &amp; 1)? -1 : 1) * solve(m / nd, u, nsz); &#125; return res * (sz &amp; 1 ? -1 : 1);&#125;int main()&#123;#ifdef DEBUG freopen("input.txt", "r", stdin);#endif // DEBUG scanf("%lld %lld", &amp;m, &amp;n); init(); ll _n = n; int sign = 0; REP(i, 0, cnt) &#123; if(_n % p[i] == 0) &#123; d[sz++] = p[i]; int bug = 0; while(_n % p[i] == 0) _n /= p[i], bug++; sign = max(sign, bug); &#125; if(_n == 1) break; &#125; if(_n != 1) d[sz++] = _n; if(sign &gt; 1) return puts("0"), 0; ll ans = solve(m, d, sz); printf("%lld\n", ans); return 0;&#125;/**************/ 第二份ac代码，改改风格，优雅路线123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;ctime&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const ll LINF = 0x3f3f3f3f3f3f3f3f;const int INF = 0x7f7f7f7f;const ll mod = 1e9 + 7;const double PI = acos(-1.0);const double eps = 1e-6;const int maxn = 1e6 + 7;#define REP(i, j, k) for(int i = j;i &lt; k; ++i)#define PER(i, j, k) for(int i = k - 1;i &gt;= j; --i)ll n, _n, m, u[20], sz, nsz, d[maxn], U[maxn];ll p[maxn], vis[maxn], cnt, mu[maxn];map&lt;ll, ll&gt; mp;void init()&#123; mu[1] = 1; cnt = 0; REP(i, 2, maxn) &#123; if(!vis[i]) p[cnt++] = i, mu[i] = -1; REP(j, 0, cnt) &#123; if(p[j] * i &gt;= maxn) break; vis[p[j] * i] = 1; if(i % p[j] == 0) &#123;mu[i * p[j]] = 0; break;&#125; mu[i * p[j]] = -mu[i]; &#125; &#125; REP(i, 2, maxn) mu[i] += mu[i - 1];&#125;ll cal(ll m)&#123; if(m &lt; maxn) return mu[m]; if(mp.find(m) != mp.end()) return mp[m]; ll res = 1, last; for(ll i = 2;i &lt;= m;i = last + 1) &#123; last = m / (m / i); res -= (last - i + 1) * cal(m / i); &#125; return mp[m] = res;&#125;ll solve(ll m, ll sta)&#123; if(m == 0) return 0; ll res = cal(m); for(ll i = sta;i;i = (i - 1) &amp; sta) res += U[i] * solve(m / d[i], i); return res * U[sta];&#125;int main()&#123;#ifdef DEBUG //freopen("input.txt", "r", stdin);#endif // DEBUG init(); scanf("%lld %lld", &amp;m, &amp;n), _n = n; sz = 0; REP(i, 0, cnt) &#123; if(_n % p[i] == 0) &#123; u[sz++] = p[i]; int sign = 0; while(_n % p[i] == 0) _n /= p[i], sign++; if(sign &gt; 1) return puts("0"), 0; &#125; if(_n == 1) break; &#125; if(_n != 1) u[sz++] = _n; nsz = 1 &lt;&lt; sz; d[0] = 1, U[0] = 1; REP(i, 1, nsz) &#123; ll nd = 1; int sign = 0; REP(j, 0, sz) &#123; if(i &amp; (1 &lt;&lt; j)) nd *= u[j], sign++; &#125; d[i] = nd, U[i] = (sign &amp; 1) ? -1 : 1; &#125; ll ans = solve(m, nsz - 1); printf("%lld\n", ans); return 0;&#125;/**************/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>杜教筛</tag>
        <tag>计蒜客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018牛客暑假多校训练第五场D题]]></title>
    <url>%2F2019%2F01%2F26%2F2018%E7%89%9B%E5%AE%A2%E6%9A%91%E5%81%87%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%BA%94%E5%9C%BAD%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Topic2018牛客暑假多校训练第五场D题 Solution 考虑题意，转化为将奇数插入给定偶数序列使得逆序对数最少 偶数序列自身有逆序对，将对答案产生贡献，使用树状数组即可在O(nlogn)时间内求得 考虑奇数插入后产生的贡献，这里可以证明奇数从小到大的插入位置为递增的 证明：现在假设对于$a_i$这个数字插入的最优位置为$k$，那么当要插入$a_i + 2$这个数字时，会产生影响的只有$a_i + 1$ 假设$a_i + 1$在$k$的左边，那么我们把它暂时删去不看，此时添加$a_i + 2$的最优位置应该仍为$k$，那么此时加回$a_i + 1$，在$k$的左边，并不会产生贡献，故$a_i + 2$的最优位置仍为$k$。 假设$a_i + 1$在$k$的右边，依旧暂时删去不看$a_i + 1$，$a_i + 2$的最优位置为$k$，加回$a_i + 1$，若$a_i + 2$往右挪到$a_i + 1$的右边时，会减少$a_i + 1$的贡献，故$a_i + 2$的最优位置可能为$a_i + 1$的右边 综上，$a_i + 2$的最优位置在$k$的右边 那么奇数间没有逆序对，而我们只需要累加每个奇数的插入的最少逆序对数即可。 维护一棵线段树，当要求$a_i + 2$的贡献时，将$a_i + 1$左边的位置贡献全部加一，右边的贡献全部减一，求整个区间的最小值，区间更新区间询问。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;assert.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-10;const int maxn = 2e5 + 7;const int mod = 1e9 + 7;const double pi = acos(-1);#define FOR(i, j, k) for(int i = j;i &lt; k; ++i)#define PRE(i, j, k) for(int i = j - 1;i &gt;= k; --i)#define z i &lt;&lt; 1#define y i &lt;&lt; 1 | 1int n, a[maxn], b[maxn], pos[maxn];ll ans;void add(int p)&#123; while(p &lt;= n) &#123; b[p]++; p += p &amp; -p; &#125;&#125;ll sum(int p)&#123; ll tmp = 0; while(p &gt; 0) &#123; tmp += b[p]; p -= p &amp; -p; &#125; return tmp;&#125;struct G&#123; int l, r, m, lazy; G()&#123;&#125; G(int l, int r, int m = 0, int lazy = 0):l(l), r(r), m(m), lazy(lazy)&#123;&#125;&#125; tr[maxn &lt;&lt; 2];void push_up(int i)&#123; tr[i].m = min(tr[z].m, tr[y].m);&#125;void push_down(int i)&#123; int lazy = tr[i].lazy; tr[z].m += lazy, tr[y].m += lazy; tr[z].lazy += lazy, tr[y].lazy += lazy; tr[i].lazy = 0;&#125;void build(int l = 0, int r = n, int i = 1)&#123; tr[i] = G(l, r); if(l == r) &#123; tr[i].m = l; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; build(l, mid, z); build(mid + 1, r, y); push_up(i); &#125;&#125;void udt(int l, int r, int val, int i = 1)&#123; int L = tr[i].l, R = tr[i].r; if(L == l &amp;&amp; R == r) &#123; tr[i].m += val;tr[i].lazy += val; &#125; else &#123; int mid = (L + R) &gt;&gt; 1; push_down(i); if(l &lt;= mid) udt(l, min(r, mid), val, z); if(r &gt; mid) udt(max(l, mid + 1), r, val, y); push_up(i); &#125;&#125;int ask(int l = 0, int r = n, int i = 1)&#123; int L = tr[i].l, R = tr[i].r; if(L == l &amp;&amp; R == r) &#123; return tr[i].m; &#125; else &#123; int mid = (L + R) &gt;&gt;1; int res = INF; if(l &lt;= mid) res = min(res, ask(l, min(r, mid), z)); if(r &gt; mid) res = min(res, ask(max(l, mid + 1), y)); return res; &#125;&#125;int main()&#123;// freopen("input.txt","r",stdin); ans = 0; scanf("%d", &amp;n); FOR(i, 0, n/2) scanf("%d", a + i), pos[a[i]] = i; PRE(i, n/2, 0) ans += sum(a[i]), add(a[i]); build(); for(int i = 3;i &lt; n;i += 2) &#123; int p = pos[i - 1]; udt(0, p, 1); udt(p + 1, n, -1); ans += ask(); &#125; printf("%lld\n", ans); return 0;&#125;/**************/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>线段树</tag>
        <tag>牛客网</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 6350]]></title>
    <url>%2F2019%2F01%2F23%2Fhdu6350%2F</url>
    <content type="text"><![CDATA[Topicproblem linkAlways Online Time Limit: 8000/4000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others)Total Submission(s): 208 Accepted Submission(s): 66 Problem DescriptionWayne is an administrator of some metropolitan area network. The network he managed can be formed into a simple connected graph with n vertices and m edges, which means the graph does not contain any self-loop and there is at most one edge and at least one path between every two vertices. Furthermore, the network also meets the condition there are at most two non-intersect paths, which share no common edges, between every two vertices. Wayne knows the bandwidth of each edge in that network but it is not enough for him. He needs plenty of statistic data to display, for example, he wants to know what the maximum data rate between every two vertices is. For the sake of clarity, vertices in that are numbered from 1 to n and the maximum bits each edge could transmit per second will be given. Your task is assisting him to calculate the value of the following formula: ∑1≤s&lt;t≤n(s⊕t⊕flow(s,t)), where ⊕ means the bitwise exclusive-OR operator and flow(s,t) means the maximum bits that could be transmitted per second between vertex s and vertex t. InputThe first line contains one integer T, indicating the number of test cases.The following lines describe all the test cases. For each test case:The first line contains two integers n and m.Each of the following m lines contains three integers u,v and w, indicating a bidirectional edge between vertex u and vertex v that can transmit at most w bits per second in each direction.1≤T≤100, 1≤n≤105, n−1≤m≤32(n−1), 1≤u,v≤n, u≠v, 0≤w&lt;109.It is guaranteed that the sum of n in all test cases does not exceed 106 and the size of the standard input file does not exceed 26 MiB. OutputFor each test case, print the answer in one line. Sample Input23 31 2 52 3 63 1 55 61 2 52 3 63 1 53 4 64 5 55 3 6 Sample Output27116 Hint For the first sample, flow(1, 2) = flow(1, 3) = 10, flow(2, 3) = 11. Intention给出一个无向图，不存在自环，两点间最多有一条边，两点间至少有一条路径，至多两条不相交路径。给出每条边以及两边之间的容量，询问 Solution 考虑这个图，其实就是一个仙人掌，大概就是长这样： 考虑如果是一棵树，那么两点最大流，即最小割就是两点路径上最小的边权 考虑仙人掌，意识流一下，对于两个点的最小割可能要割两条边，而这两条边一定在同一个环内，且环内最小边一定会被割掉 那么就可以预处理先把每个环内最小边删除并将权值加到这个环的每一条边上，此时将变成一棵树 对于一棵树，我们将所有边按权值从大到小枚举，通过并查集，按位记录点的贡献，对于每条边，再算出该边的贡献，累加即是答案 一开始用vector去跑图竟然爆栈了，大概是因为边太多的原因，本地扩栈不会爆RE，所以改了std的dfs写法，解决了segment fault 的问题，然后TLE了，将位统计的64改成32就ac了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;functional&gt;#include &lt;ctime&gt;#include &lt;assert.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const ll mod = 1e9 + 7;const double PI = acos(-1.0);const double eps = 1e-10;const int maxn = 4e5 + 7;#define REP(i, j, k) for(int i = j;i &lt;= k; ++i)#define PER(i, j, k) for(int i = j;i &gt;= k; --i)int t, n, m, vis[maxn], dep[maxn], prt[maxn], bit[maxn][40], num[maxn], tot, fae[maxn], f[maxn];int e[maxn], g[maxn], nt[maxn];struct G&#123; int u, v, w, id; G()&#123;&#125; G(int u, int v, int w, int id):u(u), v(v), w(w), id(id)&#123;&#125; bool operator &lt; (const G &amp; b) const &#123;return w &gt; b.w;&#125;&#125; edge[maxn];int get_prt(int a)&#123; return prt[a] = (prt[a] == a) ? a : get_prt(prt[a]);&#125;ll Union (int a, int b, int w)&#123; int fa = get_prt(a), fb = get_prt(b); ll res = 0; if(fa == fb) return res; REP(i, 0, 31) &#123; if(!(w &amp; (1ll &lt;&lt; i))) &#123; res += 1ll * bit[fa][i] * (num[fb] - bit[fb][i]) * (1ll &lt;&lt; i); res += 1ll * (num[fa] - bit[fa][i]) * bit[fb][i] * (1ll &lt;&lt; i); &#125; else &#123; res += 1ll * bit[fa][i] * bit[fb][i] * (1ll &lt;&lt; i); res += 1ll * (num[fa] - bit[fa][i]) * (num[fb] - bit[fb][i]) * (1ll &lt;&lt; i); &#125; &#125; prt[fb] = fa; num[fa] += num[fb]; REP(i, 0, 31) &#123; bit[fa][i] += bit[fb][i]; &#125; return res;&#125;void init()&#123; memset(dep, 0, sizeof(dep)); memset(vis, 0, sizeof(vis)); memset(fae, 0, sizeof(fae)); memset(bit, 0, sizeof(bit)); memset(f, 0, sizeof(f)); memset(nt, 0, sizeof(nt)); memset(g, 0, sizeof(g));&#125;void adde(int u, int v)&#123; e[++tot] = v; nt[tot] = g[u]; g[u] = tot; e[++tot] = u; nt[tot] = g[v]; g[v] = tot;&#125;void dfs(int u, int pre)&#123; f[u] = pre; dep[u] = ++tot; for(int i = g[u];i;i = nt[i]) &#123; if(e[i] == pre) continue; if(!dep[e[i]]) fae[e[i]] = i &gt;&gt; 1, dfs(e[i], u); else if(dep[e[i]] &lt; dep[u]) &#123; int v = u; vector&lt;int&gt; vec; vec.push_back(i &gt;&gt; 1); while(v != e[i]) vec.push_back(fae[v]), v = f[v]; int Min = 1e9 + 1, pos = 0; REP(j, 0, vec.size() - 1) &#123; if(edge[vec[j]].w &lt; Min) Min = edge[vec[j]].w, pos = j; &#125; vis[vec[pos]] = 1; REP(j, 0, vec.size() - 1) &#123; if(j != pos) edge[vec[j]].w += edge[vec[pos]].w; &#125; &#125; &#125;&#125;int main()&#123;#ifdef DEBUG freopen("input.txt", "r", stdin);#endif // DEBUG scanf("%d", &amp;t); while(t--) &#123; init(); scanf("%d %d", &amp;n, &amp;m); REP(i, 1, n) &#123; int _i = i, cnt = 0; while(_i) bit[i][cnt++] = _i % 2, _i /= 2; num[i] = 1; prt[i] = i; &#125; int u, v, w; tot = 1; REP(i, 1, m) scanf("%d %d %d", &amp;u, &amp;v, &amp;w), edge[i] = G(u, v, w, i), adde(u, v); dfs(1, 0); sort(edge + 1, edge + m + 1); ll ans = 0; REP(i, 1, m) &#123; if(vis[edge[i].id]) continue; int u = edge[i].u, v = edge[i].v, w = edge[i].w; //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl; ans += Union(u, v, w); &#125; printf("%llu\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>网络流</tag>
        <tag>并查集</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
</search>
