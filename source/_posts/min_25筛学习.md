---
title: min_25筛学习
tags: 
- acm
- min_25筛
- 笔记
- 数论
- 积性函数

---

![Alt text](./987068.jpg)
<!-- more -->
# 写在前面
之前听过min_25筛这个神奇的东西，只知道个大概，不很了解， 又由于最近在刷project euler，对数论方面知识更加来劲了。因此乘着假期空闲，便把min_25筛的资料翻出来学习了一遍，并在这里把学到的知识做一番总结。
首先，在这里先给出一些定义以便于后文描述。
- 域为正整数集，陪域为复数集的函数被称为数论函数。
- 满足$$f(a * b) = f(a) * f(b)$$成立当$$gcd(a, b) = 1$$的数论函数$$f(x)$$称为积性函数
- 记积性函数前缀和$$S(n) = \sum_{i = 1}^{n}f(i)$$。
- 记前缀和素数部分为$$S_{p}(n) = \sum_{i \in prime}^{n}f(i)$$，<br>记前缀和合数部分为$$S_{cn}(n) = \sum_{i \notin prime \cap i != 1}^{n}f(i)$$。
- 记$p_i$表示第$i$个素数，有$p_0 = 2,p_1 = 3...$。
- 记$min_i$表示数$i$的最小质因子，$max_i$表示数$i$的最大质因子。



# 分析
首先，我们考虑积性函数前缀和可以如下拆解:
$$S(n) = S_{p}(n) + S_{cn}(n) + f(1)$$
我们这个算法要先计算素数部分，之后通过素数部分快速计算整体答案。
## 素数部分
### 推导
我们都学过埃氏筛，回忆一下，我们每次得到一个素数$p$，并将那些大于等于$p^2$的$p$的倍数筛去（因为$p^2$是最小质因子为$p$的最小合数），最后就能筛得范围内的全部素数。
效仿这个思路，我们记$g(n, m)$表示积性函数前$n$个函数值中筛去那些最小质因子小于$p_m$的合数之后的和，即
$$g(n, m) = \sum_{i \in prime || max_i >= p_m}^n f(i)$$

由于大多数积性函数$f(x)$在$x \in prime$可以表示为$x^a$的线性组合，因此我们需要解决的就是$f(x) = x ^ a(x \in prime)$的前缀和。
定义新函数$f_p(x) = x ^ a$
那么初始化$g(n, 0)$，就是将合数和素数都当作素数来计算，相当于埃氏筛初始化$vis$数组，将合数和素数都标记为$0$。即
$$g(n, 0) = \sum_{i = 1}^n f_p(i) = \sum_{i = 1}^n i ^ a$$
（这个前缀和是存在高效算法可以快速计算的，如：拉格朗日插值法——复杂度O（a））
然后考虑转移，枚举$p_i$
- 当$p_i ^ 2>n$时，有$g(n, i + 1) = g(n, i)$（因为此时已经不存在最小质因子大于等于$p_i$的合数了）
- 当$p_i ^2 <= n$时，有$$g(n, i + 1)= g(n, i) - p_i^a * [g(\lfloor \frac n {p_i} \rfloor, i) - \sum_{j = 0}^{i - 1}p_j^a]$$<br>这里是这样考虑的：我们要筛去以$p_i$为最小质因子的所有合数，这些合数可以表示为$$u * p_i$$，又$$f_p(x) = x ^ a$$为一个积性函数，那么$$f_p(u * p_i) = f_p(u) * f_p(p_i)$$，于是可以将公共因子提出来，得到$$f_p(p_i) * \sum{f_p(u)}$$。<br>考虑$$\sum{f_p(u)}$$这一块的东西，$$u$$不包含小于$$p_i$$的质因子，且$$u <= \lfloor \frac n {p_i} \rfloor$$。而$$g(\lfloor \frac n {p_i} \rfloor, i)$$包含素数和最小质因子大于等于$$p_i$$的合数，于是我们还需减去小于$$p_i$$的那部分素数就能得到$$\sum{f_p(u)}$$了，即$$g(\lfloor \frac n {p_i} \rfloor, i) - \sum_{j = 0}^{i - 1}p_j^a$$于是得到如上递推公式。  


通过递推最终我们求得$S_p(n)$


### 实现
由分块思想我们知道，$\lfloor \frac n {p_i} \rfloor$只有$O(\sqrt n)$种取值。
证明：
- 当$i < \sqrt n$时，$i$有$\sqrt n$个，因此$\lfloor \frac n i \rfloor$最多也有$\sqrt n$个。
- 当$\sqrt n <= i < n$时，$\lfloor \frac n i \rfloor <= \sqrt n$，因此最多也有$\sqrt n$个。

故得证。
我们先预处理出这些取值，并初始化。
枚举$p_i$到$p_i ^ 2 < n$，然后枚举$O(\sqrt n)$这些取值从大到小做递推更新便可以了。
这里的复杂度不是$O(\sqrt n * \sqrt n)$，因为枚举过程对于$g(a, i)$有情况$p_i^2 > a$的限制，所以其实更新时并不是完全更新，下面做一下完整的复杂度分析。
### 复杂度分析
**定理1**：$n$以内的素数个数有$\pi(n) = \frac n {ln(n)}$。
**定理2**：对数积分$li(x) = \int_0^n \frac {dx} {ln(x)}$，根据其泰勒展开式$li(x) = \frac x {ln(x)} \sum_{k = 0}^\infty \frac {k!} {(ln x)^k}$可知当x趋近于0时，$li(x)\sim \frac x { ln(x)}$。
对于上述的算法，我们对于每一个取值$a$，只有在$p_i^2 <= a$的情况下会做更新，相当于每一个小于等于$\sqrt a$的素数都会有贡献。
于是有复杂度为
$$\sum_{x = 1} ^ {\sqrt n}\pi(x) + \sum_{x = 1} ^ {\sqrt n} \pi(\lfloor \frac n x \rfloor)$$
$$= O(\int_1^{\sqrt n}\pi(\lfloor \frac n x \rfloor))$$
$$= O(\int_1^{\sqrt n}\frac{\lfloor \frac n x \rfloor}{ln(\lfloor \frac n x \rfloor)}dx)$$
令$t = \lfloor \frac n x \rfloor$，则$n^{\frac 1 4} <= t <= n^{\frac 1 2}$，故原式
$$= O(\int_{n^{\frac 1 4}}^{n^{\frac 1 2}}\frac t {ln(t)} d \frac n {t^2})$$
$$= O(\int_{n^{\frac 1 4}}^{n^{\frac 1 2}}\frac {\frac {-2n} {t^2}} {ln(t)} dt)$$
$$= O(-2n\int_{n^{\frac 1 4}}^{n^{\frac 1 2}}\frac 1 {ln(\frac 1 t)} d \frac 1 t)$$
令$u = \frac 1 t$，有$$= O(-2n\int_{n^{-\frac 1 2}}^{n^{-\frac 1 4}}\frac 1 {ln(u)} d u)$$
根据定理2
$$= O(-2n[\frac {n^{-\frac 1 4}}{ln({n^{-\frac 1 4}})} - \frac {n^{-\frac 1 2}} {ln(n^{-\frac 1 2})}])$$
$$= O(\frac {8n^{\frac 3 4}}{ln(n)} - \frac {4n^{\frac 1 2}} {ln(n)})$$
$$= O(\frac {8n^{\frac 3 4}}{ln(n)})$$
综上，该算法复杂度为复杂度$O(\frac {8n^{\frac 3 4}}{ln(n)})$，是一个亚线性算法，时空复杂度都算得上优秀。
## 整体计算
### 推导
我们记$G(n, m)$表示所有最小质因子大于等于$p_m$的数的函数值之和。
那么可以知道$G(n, 0) + f(1)$就是我们要求的答案
那么考虑如何递推$G(n, m)$
- 当$p_i > n$时，此时$G(n, i)$为$0$
- 当$p_i <= n$时，有<br>$$G(n, i) = f_p(n) - \sum_{j = 0}^{i - 1}f(j) + \sum_{k = i}^{p_k^2<=n}\sum_{e = 1}^{p_k^{e + 1} <= n}[f(p_k^e)*G(\lfloor \frac n {p_k^e} \rfloor, k + 1) + f(p_k^{e + 1})]$$<br>前半部分$f_p(n) - \sum_{j = 0}^{i - 1}f(j)$为前$n$个数里大于等于$p_i$的素数的答案。<br>后半部分$\sum_{k = i}^{p_k^2<=n}\sum_{e = 1}^{p_k^{e + 1} <= n}[f(p_k^e)*G(\lfloor \frac n {p_k^e} \rfloor, k + 1) + f(p_k^{e + 1})]$为暴力枚举每个数的最小质因子的取值以及重复的次数，将合数部分计算进来。

### 实现
实现直接暴力深搜就可以了。可以dp递推，那样的时间复杂度据说为$O(\frac {n^{\frac 3 4}} {log(n)})$。（然而我并不会）
### 复杂度
在数据小的情况下，直接暴搜的复杂度优于$O(\frac {n^{\frac 3 4}} {log(n)})$，这里不再做详细分析，等下回研究透了再来补上，以及dp递推做法。

# 后记
对于min_25筛这个算法，相比于杜教筛，我个人认为比较好理解。而理解这个算法关键还是要和埃氏筛结合思考，抓住像分块这样的小技巧。
花了很多心思在min_25筛这个算法上，因为听得太多次了，加上上次在西安的热身赛上的杜教筛题目没有做出来，所以便想把它钻研透。期间看了很多资料，拓展了许多知识，并不局限于当前算法。
# 参考文献
- [一个大佬的blog](https://www.cnblogs.com/zbh2047/p/8552551.html)
- 《一些特殊的数论函数求和问题》朱震霆

